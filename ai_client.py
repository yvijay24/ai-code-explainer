# ai_client.py (Semantic Highlighting Enabled)
import os
import json
import re
from typing import Optional, Dict
from openai import OpenAI

OPENAI_MODEL = os.getenv("OPENAI_MODEL", "gpt-4o-mini")


class AIClient:
    def __init__(self):
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            raise RuntimeError("OPENAI_API_KEY is not set")

        self.client = OpenAI(api_key=api_key)

    def extract_json(self, text: str) -> Dict:
        """
        Extracts JSON even if the model adds text before/after it.
        """

        # Try direct load
        try:
            return json.loads(text)
        except:
            pass

        # Try substring extraction
        try:
            match = re.search(r"\{[\s\S]*\}", text)
            if match:
                return json.loads(match.group(0))
        except:
            pass

        # Fallback
        return {
            "detected_language": "unknown",
            "explanation": "Model response could not be parsed.",
            "key_points": [],
            "complexity": "unknown",
            "optimized_code": "",
            "highlighted_code": ""
        }

    def explain_code(self, code: str, language: str, ast_summary: Optional[str] = "") -> Dict:

        system_prompt = (
            "You are a code analysis assistant. You analyze, explain, optimize, "
            "and semantically highlight code. You MUST always return JSON.\n\n"

            "=== OPTIMIZATION RULES ===\n"
            "You MUST ALWAYS provide an optimized version of the code.\n"
            "Optimized code must never be empty.\n"
            "Use these optimization strategies:\n"
            "1. Performance optimization (e.g., reducing console.log calls, avoiding redundant loops)\n"
            "2. Readability improvements (indentation, cleaner syntax, better variable names)\n"
            "3. Algorithmic improvements if possible\n"
            "4. Structural improvements (extract functions, reduce nesting)\n"
            "If no algorithmic improvement is possible, improve formatting + readability.\n\n"

            "=== SEMANTIC HIGHLIGHT TAGS ===\n"
            "<func>...</func> for function definitions\n"
            "<loop>...</loop> for loops\n"
            "<cond>...</cond> for conditions\n"
            "<ret>...</ret> for return statements\n"
            "<var>...</var> for variables\n"
            "<call>...</call> for function calls\n"
            "<comment>...</comment> for comments\n\n"

            "=== COMPLEXITY RULES ===\n"
            "Always include BOTH time and space complexity in one line:\n"
            "\"Time: O(...), Space: O(...)\"\n\n"

            "=== OUTPUT FORMAT (MANDATORY) ===\n"
            "You must return ONLY valid JSON with fields:\n"
            "{\n"
            '  "detected_language": "",\n'
            '  "explanation": "",\n'
            '  "key_points": [],\n'
            '  "complexity": "",\n'
            '  "optimized_code": "",\n'
            '  "highlighted_code": ""\n'
            "}\n"
        )

        user_prompt = (
            f"Analyze the following code:\n```{language}\n{code}\n```\n\n"
            f"Here is a structural AST summary generated by a parser (do NOT ignore it):\n"
            f"--- AST SUMMARY START ---\n{ast_summary}\n--- AST SUMMARY END ---\n\n"
            "Use the AST hints to avoid structural errors or hallucinations.\n"
            "Return ONLY valid JSON.\n\n"
            "{\n"
            '  "detected_language": "",\n'
            '  "explanation": "",\n'
            '  "key_points": [],\n'
            '  "complexity": "",\n'
            '  "optimized_code": "",\n'
            '  "highlighted_code": ""\n'
            "}\n"
        )

        response = self.client.chat.completions.create(
            model=OPENAI_MODEL,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user",  "content": user_prompt}
            ],
            temperature=0
        )

        msg = response.choices[0].message
        raw_text = msg.get("content") if isinstance(msg, dict) else msg.content

        data = self.extract_json(raw_text)

        return {
            "detected_language": data.get("detected_language", "unknown"),
            "explanation": data.get("explanation", ""),
            "key_points": data.get("key_points", []),
            "complexity": data.get("complexity", ""),
            "optimized_code": data.get("optimized_code", ""),
            "highlighted_code": data.get("highlighted_code", "")
        }
